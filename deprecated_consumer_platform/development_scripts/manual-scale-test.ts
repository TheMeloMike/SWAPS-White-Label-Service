// Import from node_modules rather than relative paths
import * as crypto from 'crypto';
import * as fs from 'fs';
import * as path from 'path';

// Generate unique IDs without external dependencies
function generateId(): string {
  return crypto.randomBytes(16).toString('hex');
}

// Define Trade type
interface TradeStep {
  from: string;
  to: string;
  nft: string;
}

interface Trade {
  id: string;
  steps: TradeStep[];
}

// Trade test configuration
const CONFIG = {
  walletCount: 5000,
  nftCount: 50000,
  nftsPerWallet: {min: 1, max: 10},
  wantsPerWallet: {min: 1, max: 20},
  tradePatterns: {
    directSwap: 0.2,
    circular3: 0.15, 
    circular4to6: 0.1,
    random: 0.55
  }
};

async function runTest() {
  console.log('=== SWAPS Algorithm Scale Test ===');
  console.log(`Testing with ${CONFIG.walletCount} wallets and ${CONFIG.nftCount} NFTs`);
  
  // Generate wallets, NFTs, and preferences
  console.log('\nGenerating test data...');
  const startTime = performance.now();
  
  // Generate wallets
  const wallets: string[] = [];
  for (let i = 0; i < CONFIG.walletCount; i++) {
    wallets.push(`wallet_${generateId().substring(0, 8)}`);
  }
  
  // Generate NFTs
  const nfts: string[] = [];
  for (let i = 0; i < CONFIG.nftCount; i++) {
    nfts.push(`nft_${generateId().substring(0, 8)}`);
  }
  
  // Track NFT ownership and preferences
  const nftOwnership = new Map<string, string>();
  const walletNfts = new Map<string, string[]>();
  const walletWants = new Map<string, string[]>();
  
  wallets.forEach(wallet => {
    walletNfts.set(wallet, []);
    walletWants.set(wallet, []);
  });
  
  // Distribute NFTs to wallets
  const availableNfts = [...nfts];
  
  for (const wallet of wallets) {
    const nftCount = Math.floor(
      CONFIG.nftsPerWallet.min + 
      Math.random() * (CONFIG.nftsPerWallet.max - CONFIG.nftsPerWallet.min + 1)
    );
    
    for (let i = 0; i < nftCount && availableNfts.length > 0; i++) {
      const randomIndex = Math.floor(Math.random() * availableNfts.length);
      const nft = availableNfts.splice(randomIndex, 1)[0];
      
      walletNfts.get(wallet)?.push(nft);
      nftOwnership.set(nft, wallet);
    }
  }
  
  // Distribute remaining NFTs
  while (availableNfts.length > 0) {
    const randomWalletIndex = Math.floor(Math.random() * wallets.length);
    const wallet = wallets[randomWalletIndex];
    const nft = availableNfts.pop()!;
    
    walletNfts.get(wallet)?.push(nft);
    nftOwnership.set(nft, wallet);
  }
  
  // Generate trade patterns
  const { directSwap, circular3, circular4to6 } = CONFIG.tradePatterns;
  
  const directSwapWallets = Math.floor(wallets.length * directSwap);
  const circular3Wallets = Math.floor(wallets.length * circular3);
  const circular4to6Wallets = Math.floor(wallets.length * circular4to6);
  
  // Create wallet pools
  const availableWallets = [...wallets];
  
  // Create direct swaps (A wants B's NFT, B wants A's NFT)
  for (let i = 0; i < directSwapWallets / 2 && availableWallets.length >= 2; i++) {
    const walletAIndex = Math.floor(Math.random() * availableWallets.length);
    const walletA = availableWallets.splice(walletAIndex, 1)[0];
    
    const walletBIndex = Math.floor(Math.random() * availableWallets.length);
    const walletB = availableWallets.splice(walletBIndex, 1)[0];
    
    const nftsA = walletNfts.get(walletA) || [];
    const nftsB = walletNfts.get(walletB) || [];
    
    if (nftsA.length > 0 && nftsB.length > 0) {
      const nftA = nftsA[Math.floor(Math.random() * nftsA.length)];
      const nftB = nftsB[Math.floor(Math.random() * nftsB.length)];
      
      walletWants.get(walletA)?.push(nftB);
      walletWants.get(walletB)?.push(nftA);
    }
  }
  
  // Create 3-way circular trades (A→B→C→A)
  for (let i = 0; i < circular3Wallets / 3 && availableWallets.length >= 3; i++) {
    const wallets = [];
    for (let j = 0; j < 3; j++) {
      const index = Math.floor(Math.random() * availableWallets.length);
      wallets.push(availableWallets.splice(index, 1)[0]);
    }
    
    for (let j = 0; j < 3; j++) {
      const currentWallet = wallets[j];
      const nextWallet = wallets[(j + 1) % 3];
      
      const nextWalletNfts = walletNfts.get(nextWallet) || [];
      if (nextWalletNfts.length > 0) {
        const nft = nextWalletNfts[Math.floor(Math.random() * nextWalletNfts.length)];
        walletWants.get(currentWallet)?.push(nft);
      }
    }
  }
  
  // Create larger circular trades (4-6 parties)
  const possibleSizes = [4, 5, 6];
  let remainingCircularWallets = circular4to6Wallets;
  
  while (remainingCircularWallets > 0 && availableWallets.length >= 4) {
    const size = possibleSizes[Math.floor(Math.random() * possibleSizes.length)];
    
    if (availableWallets.length < size) break;
    
    const wallets = [];
    for (let j = 0; j < size; j++) {
      const index = Math.floor(Math.random() * availableWallets.length);
      wallets.push(availableWallets.splice(index, 1)[0]);
    }
    
    for (let j = 0; j < size; j++) {
      const currentWallet = wallets[j];
      const nextWallet = wallets[(j + 1) % size];
      
      const nextWalletNfts = walletNfts.get(nextWallet) || [];
      if (nextWalletNfts.length > 0) {
        const nft = nextWalletNfts[Math.floor(Math.random() * nextWalletNfts.length)];
        walletWants.get(currentWallet)?.push(nft);
      }
    }
    
    remainingCircularWallets -= size;
  }
  
  // Random preferences for remaining wallets
  for (const wallet of availableWallets) {
    const wantCount = Math.floor(
      CONFIG.wantsPerWallet.min + 
      Math.random() * (CONFIG.wantsPerWallet.max - CONFIG.wantsPerWallet.min + 1)
    );
    
    const ownedNfts = new Set(walletNfts.get(wallet) || []);
    const availableNfts = nfts.filter(nft => !ownedNfts.has(nft));
    
    for (let i = 0; i < wantCount && i < availableNfts.length; i++) {
      const randomIndex = Math.floor(Math.random() * availableNfts.length);
      const nft = availableNfts.splice(randomIndex, 1)[0];
      
      walletWants.get(wallet)?.push(nft);
    }
  }
  
  // Calculate distribution stats
  let minNfts = Infinity, maxNfts = 0, totalNfts = 0;
  let minWants = Infinity, maxWants = 0, totalWants = 0;
  
  for (const wallet of wallets) {
    const nfts = walletNfts.get(wallet) || [];
    minNfts = Math.min(minNfts, nfts.length);
    maxNfts = Math.max(maxNfts, nfts.length);
    totalNfts += nfts.length;
    
    const wants = walletWants.get(wallet) || [];
    minWants = Math.min(minWants, wants.length);
    maxWants = Math.max(maxWants, wants.length);
    totalWants += wants.length;
  }
  
  const endTime = performance.now();
  const generationTime = Math.round(endTime - startTime);
  
  console.log(`Data generation completed in ${generationTime}ms`);
  console.log(`- ${wallets.length} wallets created`);
  console.log(`- ${nfts.length} NFTs created`);
  console.log(`- NFT distribution: min=${minNfts}, max=${maxNfts}, avg=${(totalNfts / wallets.length).toFixed(2)}`);
  console.log(`- Wants distribution: min=${minWants}, max=${maxWants}, avg=${(totalWants / wallets.length).toFixed(2)}`);
  
  // -----------------------------------------------------
  // Since we can't integrate with the actual algorithm directly,
  // simulate processing the algorithm with the trade patterns
  // -----------------------------------------------------
  console.log('\nSimulating algorithm performance with this data...');
  const algoStartTime = performance.now();
  
  // Simple trade finder that looks for direct trades and circular patterns
  const directTrades = findDirectTrades(wallets, walletNfts, walletWants, nftOwnership);
  const circularTrades = findCircularTrades(wallets, walletNfts, walletWants, nftOwnership);
  
  const algoEndTime = performance.now();
  const processingTime = Math.round(algoEndTime - algoStartTime);
  
  // Calculate statistics
  const stats = {
    generationTime,
    processingTime,
    totalTradesFound: directTrades.length + circularTrades.length,
    directTrades: directTrades.length,
    circularTrades: circularTrades.length,
    largestTradeSize: 0,
    tradesBySize: {} as Record<string, number>
  };
  
  // Organize by size
  const allTrades = [...directTrades, ...circularTrades];
  for (const trade of allTrades) {
    const size = trade.steps.length;
    stats.largestTradeSize = Math.max(stats.largestTradeSize, size);
    stats.tradesBySize[size.toString()] = (stats.tradesBySize[size.toString()] || 0) + 1;
  }
  
  console.log(`Simulation completed in ${processingTime}ms`);
  console.log(`Found ${stats.totalTradesFound} potential trades`);
  console.log(`- ${stats.directTrades} direct trades (2 parties)`);
  console.log(`- ${stats.circularTrades} circular trades (3+ parties)`);
  
  // Print trade size distribution
  console.log('\nTrades by Size:');
  Object.keys(stats.tradesBySize)
    .sort((a, b) => Number(a) - Number(b))
    .forEach(size => {
      console.log(`- ${size} parties: ${stats.tradesBySize[size]} trades`);
    });
  
  // Save results
  const resultsDir = path.join(__dirname, '../../test-results');
  if (!fs.existsSync(resultsDir)) {
    fs.mkdirSync(resultsDir, { recursive: true });
  }
  
  const timestamp = new Date().toISOString().replace(/:/g, '-').replace(/\..+/, '');
  const filename = path.join(resultsDir, `scale-test-${timestamp}.json`);
  
  fs.writeFileSync(filename, JSON.stringify({
    config: CONFIG,
    stats,
    timestamp: new Date().toISOString()
  }, null, 2));
  
  console.log(`\nResults saved to ${filename}`);
}

// Simulated trade finders
function findDirectTrades(
  wallets: string[],
  walletNfts: Map<string, string[]>,
  walletWants: Map<string, string[]>,
  nftOwnership: Map<string, string>
): Trade[] {
  const trades: Trade[] = [];
  
  for (const walletA of wallets) {
    const wantsA = walletWants.get(walletA) || [];
    
    for (const nftB of wantsA) {
      const walletB = nftOwnership.get(nftB);
      
      if (!walletB) continue;
      
      // Check if B wants any of A's NFTs
      const wantsB = walletWants.get(walletB) || [];
      const nftsA = walletNfts.get(walletA) || [];
      
      const crossWants = wantsB.filter(nft => nftsA.includes(nft));
      
      if (crossWants.length > 0) {
        // Found a direct trade
        trades.push({
          id: generateId(),
          steps: [
            { from: walletA, to: walletB, nft: crossWants[0] },
            { from: walletB, to: walletA, nft: nftB }
          ]
        });
      }
    }
  }
  
  return trades;
}

function findCircularTrades(
  wallets: string[],
  walletNfts: Map<string, string[]>,
  walletWants: Map<string, string[]>,
  nftOwnership: Map<string, string>
): Trade[] {
  const trades: Trade[] = [];
  const processedPaths = new Set<string>();
  
  // Try to find circular paths of length 3+
  for (const startWallet of wallets) {
    findCircularPath(startWallet, [], new Set(), startWallet);
  }
  
  // DFS to find circular paths
  function findCircularPath(
    currentWallet: string,
    path: TradeStep[],
    visited: Set<string>,
    startWallet: string,
    depth = 0
  ): void {
    if (depth > 5) return; // Limit depth to avoid excessive computation
    
    if (depth > 0 && currentWallet === startWallet && path.length >= 3) {
      // Found a circular path
      const pathKey = path.map(step => `${step.from}-${step.to}`).join('|');
      if (!processedPaths.has(pathKey)) {
        processedPaths.add(pathKey);
        trades.push({
          id: generateId(),
          steps: [...path]
        });
      }
      return;
    }
    
    if (visited.has(currentWallet)) return;
    visited.add(currentWallet);
    
    const wantsNfts = walletWants.get(currentWallet) || [];
    
    for (const wantedNft of wantsNfts) {
      const nftOwner = nftOwnership.get(wantedNft);
      if (!nftOwner) continue;
      
      // Skip if this would create a loop before reaching startWallet again
      if (nftOwner !== startWallet && visited.has(nftOwner)) continue;
      
      // Add this step to the path
      const newPath = [...path, { from: currentWallet, to: nftOwner, nft: wantedNft }];
      
      // Continue search from next wallet
      findCircularPath(nftOwner, newPath, new Set(visited), startWallet, depth + 1);
    }
  }
  
  return trades;
}

// Run the test
runTest().catch(console.error);
